index.js:
import * as THREE from 'https://unpkg.com/three@0.122.0/build/three.module.js';
import Stats from 'https://unpkg.com/three@0.122.0/examples/jsm/libs/stats.module.js';
import { OrbitControls } from '../Scripts/lib/OrbitControls.js';
import { PointerLockControls } from 'https://unpkg.com/three@0.122.0/examples/jsm/controls/PointerLockControls.js';
import { initCube, world, bodies, getObjects, scrambleCube, solveCube, rotateLayer, rotateWholeCube } from './cube.js';
import { initPlayer } from './player.js';
import { createTriggerZones } from './cubeInteraction.js';
import { gameState, congratsModal, stopTimer } from './menu.js';

export let scene, camera, controlsPointer, observerCamera, cameraPlayer, renderer, controls;
export let CurrentActiveCam = 'observer';
let stats;
let textureLoader = new THREE.TextureLoader();
let texture_grass = textureLoader.load("https://threejs.org/examples/textures/terrain/grasslight-big.jpg");
document.getElementById('menu_settings').style.display = 'none';
let isDragging = false;
let startObject = null;
const raycaster = new THREE.Raycaster();
let arrows = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Å—Ç—Ä–µ–ª–æ–∫
let selectedCube = null;
//  —ç–ª–µ–º–µ–Ω—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
let progressBar, progress_text

addEventListener('contextmenu', (e) => {e.preventDefault()})

texture_grass.onError = () => {
    console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–µ–∫—Å—Ç—É—Ä—É —Ç—Ä–∞–≤—ã');
    texture_grass = new THREE.MeshLambertMaterial({ color: 0x00aa00 });
};

const cameraInfoDiv = document.createElement('div');
cameraInfoDiv.id = 'cameraInfo';
document.body.appendChild(cameraInfoDiv);

function initThree() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    observerCamera = new THREE.PerspectiveCamera(30, width / height, 0.5, 1000);
    cameraPlayer = new THREE.PerspectiveCamera(60, width / height, 0.5, 1000);
    observerCamera.name = 'observer';
    cameraPlayer.name = 'player';

    window.addEventListener('resize', () => {
        observerCamera.aspect = width / height;
        observerCamera.updateProjectionMatrix();
        cameraPlayer.aspect = width / height;
        cameraPlayer.updateProjectionMatrix();
        renderer.setSize(width, height);
    });

    camera = observerCamera;
    camera.position.set(15, 15, 15);
    camera.lookAt(0, 5, 0);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x86ceeb);
    scene.fog = new THREE.Fog(0x000000, 500, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(scene.fog.color);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enabled = false;
    controls.target.set(0, 5, 0);
    controls.rotateSpeed = 1.0;
    controls.zoomSpeed = 1.2;
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.dampingFactor = 0.2;
    controls.minDistance = 10;
    controls.maxDistance = 300;

    controlsPointer = new PointerLockControls(cameraPlayer, renderer.domElement);
    scene.add(controlsPointer.getObject());

    controlsPointer.addEventListener('lock', () => {
        controls.enabled = false;
        camera = cameraPlayer;
        CurrentActiveCam = 'player';
        console.log('–ö–∞–º–µ—Ä–∞: –ò–≥—Ä–æ–∫');
        updateCam();
    });

    controlsPointer.addEventListener('unlock', () => {
        controls.enabled = false;
        camera = observerCamera;
        CurrentActiveCam = 'observer';
        console.log('–ö–∞–º–µ—Ä–∞: –ù–∞–±–ª—é–¥–∞—Ç–µ–ª—å');
        updateCam();
    });

    controls.update();

    stats = new Stats();
    document.body.appendChild(stats.dom);

    const ambientLight = new THREE.AmbientLight(0x666666);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
    const distance = 20;
    directionalLight.position.set(-distance, distance, distance);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    const floorGeometry = new THREE.PlaneBufferGeometry(100, 100, 1, 1);
    floorGeometry.rotateX(-Math.PI / 2);
    const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x777777, map: texture_grass });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.translateY(-2.7);
    floor.receiveShadow = true;
    scene.add(floor);

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
    progressBar = document.createElement('div')
    progress_text = document.createElement('div')
    progress_text.id = 'progtext'
    document.body.appendChild(progress_text)
    document.getElementById(progress_text.id).textContent = '0%'
    progressBar.id = 'progressBar';
    progressBar.style.overflow = 'hidden';
    const progressFill = document.createElement('div')
    progressFill.id = 'progressFill';  
    progressBar.appendChild(progressFill);
    document.body.appendChild(progressBar)
}

// —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
export function updateProgressBar(percentage){
    const progressFill = document.getElementById('progressFill');
    console.log(`${percentage}%`)
    if (progressFill){
        progressFill.style.width = `${percentage}%`;       
        progress_text.style.color = '#ffff00'
        progress_text.textContent = `${Math.round(percentage)}%`       
    
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –ø—Ä–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ 100%
        if (percentage >= 100) {
            // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏
            setTimeout(() => {
                if (congratsModal) {
                    congratsModal.style.display = 'block';
                    stopTimer();
                }
            }, 300);
        }
    } else {
        console.error('–≠–ª–µ–º–µ–Ω—Ç—ã –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã!');
    }
}

function createArrow(position, direction, color = 0x00ff00, isRotate = false, faceColor = 0x00ff00) {
    if (!gameState.active) return
    const geometry = isRotate ? new THREE.SphereGeometry(0.2, 16, 16) : new THREE.ConeGeometry(0.3, 0.6, 8);
    const material = new THREE.MeshBasicMaterial({ color });
    const arrow = new THREE.Mesh(geometry, material);
    arrow.position.copy(position);
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ü–≤–µ—Ç
    material.userData = { originalColor: color };

    if (!isRotate) {
        // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä–µ–ª–∫–∏ –≤ –º–∏—Ä–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        const worldDirection = direction.clone().normalize();
        arrow.lookAt(position.clone().add(worldDirection.multiplyScalar(-1)));

        // —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ –≥—Ä–∞–Ω–∏ –Ω–∞ –ø–æ–≤–æ—Ä–æ—Ç—ã
        const rotationMap = {
            0xff0000: {0x00ff00: [Math.PI, 0, 0], 0xffff00: [0, 0, -Math.PI], 0x0000ff: [Math.PI, 0, 0]}, // –ö—Ä–∞—Å–Ω–∞—è –≥—Ä–∞–Ω—å
            0x00ff00: {0x00ff00: [Math.PI, 0, 0], 0xffff00: [0, 0, Math.PI / 2], 0x0000ff: [0, 0, -Math.PI / 2]}, // –ó–µ–ª–µ–Ω–∞—è –≥—Ä–∞–Ω—å
            0xffffff: { // –±–µ–ª–∞—è –≥—Ä–∞–Ω—å
                0xff0000: [Math.PI / 2, 0, -Math.PI / 2], // –ö—Ä–∞—Å–Ω–∞—è —Å—Ç—Ä–µ–ª–∫–∞ ‚Üë
                0x00ff00: [Math.PI / 2, 0, -Math.PI / 2], // –ó–µ–ª–µ–Ω–∞—è —Å—Ç—Ä–µ–ª–∫–∞ ‚Üì
                0x0000ff: [-Math.PI / 2, 0, -Math.PI / 2],// –°–∏–Ω—è—è   —Å—Ç—Ä–µ–ª–∫–∞ ‚Üí
                0xffff00: [Math.PI / 2, 0, -Math.PI / 2], // –ñ–µ–ª—Ç–∞—è  —Å—Ç—Ä–µ–ª–∫–∞ ‚Üê
            },
            0xffff00: { // –ñ–µ–ª—Ç–∞—è –≥—Ä–∞–Ω—å
                0xff0000: [Math.PI / 2, 0, Math.PI / 2],
                0x00ff00: [Math.PI / 2, 0, Math.PI / 2],
                0x0000ff: [-Math.PI / 2, 0, Math.PI /2],
                0xffff00: [Math.PI, 0, Math.PI / 2],
            },
            0x0000ff: { // –°–∏–Ω—è—è –≥—Ä–∞–Ω—å
                0x00ff00: [0, 0, Math.PI],
                0x0000ff: [-Math.PI / 2, 0, Math.PI / 2],
                0xffff00: [Math.PI / 2, 0, -Math.PI / 2],
            },
            0xffa500: { /* –û—Ä–∞–Ω–∂–µ–≤–∞—è –≥—Ä–∞–Ω—å */ 0x00ff00: [Math.PI, 0, 0] }
        };

        const rot = rotationMap[faceColor]?.[color];
        if (rot){
            arrow.rotateX(rot[0]);
            arrow.rotateY(rot[1]);
            arrow.rotateZ(rot[2]);
        }

        // –ë–ª–æ–∫–∏—Ä—É–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ —Å—Ç—Ä–µ–ª–∫–∏
        arrow.matrixAutoUpdate = false;
        arrow.updateMatrix();
    }

    arrow.userData = { direction };
    if (isRotate) {
        arrow.userData.isRotate = true;
        // –£–∫–∞–∑—ã–≤–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤—Ä–∞—â–µ–Ω–∏—è: –ø–æ —á–∞—Å–æ–≤–æ–π (true) –∏–ª–∏ –ø—Ä–æ—Ç–∏–≤ (false)
        arrow.userData.rotationDirection = color === 0x00CED1 ? false : true;
    }
    scene.add(arrow);
    return arrow;
}

function showArrows(cube) {
    // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Å—Ç—Ä–µ–ª–∫–∏
    arrows.forEach(arrow => scene.remove(arrow));
    arrows = [];

    const cubeSize = 6.12 / 3; // –†–∞–∑–º–µ—Ä –æ–¥–Ω–æ–≥–æ –∫—É–±–∏–∫–∞
    const offset = cubeSize * 0.5; // –û—Ç—Å—Ç—É–ø –¥–ª—è —Å—Ç—Ä–µ–ª–æ–∫
    const extrudeOffset = cubeSize * 0.1; // –°–º–µ—â–µ–Ω–∏–µ —Å—Ç—Ä–µ–ª–æ–∫ –Ω–∞—Ä—É–∂—É
    const sphereOffset = cubeSize * 0.1; // –°–º–µ—â–µ–Ω–∏–µ —à–∞—Ä–æ–≤ –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–µ

    // –ù–∞—Ö–æ–¥–∏–º –≥—Ä–∞–Ω—å, –Ω–∞ –∫–æ—Ç–æ—Ä—É—é –∫–ª–∏–∫–Ω—É–ª–∏
    const mouse = new THREE.Vector2();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -((event.clientY / window.innerHeight) * 2 - 1);
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects([cube], true);
    if (intersects.length === 0) return;

    const intersect = intersects[0];
    const normal = intersect.face.normal.clone().applyMatrix4(cube.matrixWorld).sub(cube.getWorldPosition(new THREE.Vector3())).normalize();

    // –ü–æ–∑–∏—Ü–∏—è —Ü–µ–Ω—Ç—Ä–∞ –∫–ª–∏–∫–Ω—É—Ç–æ–π –≥—Ä–∞–Ω–∏
    const position = cube.getWorldPosition(new THREE.Vector3()).add(normal.clone().multiplyScalar(cubeSize * 0.5));

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–≤–µ—Ç –≥—Ä–∞–Ω–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–æ—Ä–º–∞–ª–∏
    let faceColor;
    const absNormal = new THREE.Vector3(Math.abs(normal.x), Math.abs(normal.y), Math.abs(normal.z));
    if (absNormal.x > 0.9) {
        faceColor = normal.x > 0 ? 0xff0000 : 0xffa500; // –ö—Ä–∞—Å–Ω–∞—è –∏–ª–∏ –æ—Ä–∞–Ω–∂–µ–≤–∞—è –≥—Ä–∞–Ω—å
    } else if (absNormal.y > 0.9) {
        faceColor = normal.y > 0 ? 0xffffff : 0xffff00; // –ë–µ–ª–∞—è –∏–ª–∏ –∂—ë–ª—Ç–∞—è –≥—Ä–∞–Ω—å
    } else if (absNormal.z > 0.9) {
        faceColor = normal.z > 0 ? 0x00ff00 : 0x0000ff; // –ó–µ–ª—ë–Ω–∞—è –∏–ª–∏ —Å–∏–Ω—è—è –≥—Ä–∞–Ω—å
    }

    // –í—ã—á–∏—Å–ª—è–µ–º –≤–µ–∫—Ç–æ—Ä—ã "–≤–≤–µ—Ä—Ö" –∏ "–≤–ø—Ä–∞–≤–æ" –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–æ—Ä–º–∞–ª–∏ –∫–ª–∏–∫–Ω—É—Ç–æ–π –≥—Ä–∞–Ω–∏
    let upVector = new THREE.Vector3(0, 1, 0); // –ù–∞—á–∞–ª—å–Ω—ã–π "–≤–≤–µ—Ä—Ö"
    if (Math.abs(normal.dot(upVector)) > 0.9) {
        upVector.set(0, 0, 1); // –ï—Å–ª–∏ –Ω–æ—Ä–º–∞–ª—å –±–ª–∏–∑–∫–∞ –∫ Y, –∏—Å–ø–æ–ª—å–∑—É–µ–º Z –∫–∞–∫ "–≤–≤–µ—Ä—Ö"
    }
    const rightVector = new THREE.Vector3().crossVectors(normal, upVector).normalize();
    upVector.crossVectors(rightVector, normal).normalize();

    // –°–º–µ—â–µ–Ω–∏–µ –¥–ª—è "–≤—ã–¥–∞–≤–ª–∏–≤–∞–Ω–∏—è" —Å—Ç—Ä–µ–ª–æ–∫ –∑–∞ –≥—Ä–∞–Ω—å
    const extrudeVector = normal.clone().multiplyScalar(extrudeOffset);

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∫–ª–∏–∫–Ω—É—Ç—ã–π –∫—É–±–∏–∫ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–º
    const cubesObjects = getObjects();
    const centerCubes = cubesObjects.filter(item => item.name.includes("CENTER"));
    const isCenterCube = centerCubes.some(center => center === cube || center.uuid === cube.uuid);

    // –°—Ç—Ä–µ–ª–∫–∏ –¥–ª—è –≤—Å–µ—Ö –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π (‚¨Ü‚¨á‚¨Ö‚û°)
    const directions = [
        { dir: rightVector.clone(), pos: upVector.clone().multiplyScalar(offset), color: 0xff0000 }, // ‚Üë (–∫—Ä–∞—Å–Ω—ã–π)
        { dir: rightVector.clone().negate(), pos: upVector.clone().negate().multiplyScalar(offset), color: 0x00ff00 }, // ‚Üì (–∑–µ–ª—ë–Ω—ã–π)
        { dir: upVector.clone(), pos: rightVector.clone().negate().multiplyScalar(offset), color: 0x0000ff }, // ‚Üí (—Å–∏–Ω–∏–π)
        { dir: upVector.clone().negate(), pos: rightVector.clone().multiplyScalar(offset), color: 0xffff00 }, // ‚Üê (–∂–µ–ª—Ç—ã–π)
    ];

    directions.forEach(({ dir, pos, color }) => {
        const arrowPos = position.clone().add(extrudeVector).add(pos);
        const arrow = createArrow(arrowPos, dir, color, false, faceColor);
        arrows.push(arrow);
    });

    // –î–æ–±–∞–≤–ª—è–µ–º —à–∞—Ä—ã —Ç–æ–ª—å–∫–æ –¥–ª—è —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã—Ö –∫—É–±–∏–∫–æ–≤ —Å—Ç–æ—Ä–æ–Ω
    if (isCenterCube) {
        const centerPos = position.clone().add(extrudeVector); // –¶–µ–Ω—Ç—Ä –≥—Ä–∞–Ω–∏
        // –ë–∏—Ä—é–∑–æ–≤—ã–π —à–∞—Ä (–ø–æ —á–∞—Å–æ–≤–æ–π) —á—É—Ç—å –≤—ã—à–µ —Ü–µ–Ω—Ç—Ä–∞
        const turquoisePos = centerPos.clone().add(upVector.clone().multiplyScalar(sphereOffset + 0.025));
        const counterclockwiseSphere = createArrow(turquoisePos, normal, 0x00CED1, true); // –ë–∏—Ä—é–∑–æ–≤—ã–π —à–∞—Ä
        // –ß—ë—Ä–Ω—ã–π —à–∞—Ä (–ø—Ä–æ—Ç–∏–≤ —á–∞—Å–æ–≤–æ–π) —á—É—Ç—å –Ω–∏–∂–µ —Ü–µ–Ω—Ç—Ä–∞
        const blackPos = centerPos.clone().add(upVector.clone().negate().multiplyScalar(sphereOffset + 0.025));
        const clockwiseSphere = createArrow(blackPos, normal, 0x000001, true); // –ß—ë—Ä–Ω—ã–π —à–∞—Ä 
        arrows.push(clockwiseSphere, counterclockwiseSphere);
    }   
    console.log(`Total arrows created: ${arrows.length}`);
}

function hideArrows() {
    arrows.forEach(arrow => scene.remove(arrow));
    arrows = [];
    selectedCube = null;
}

document.addEventListener('keydown', (event) => {
    let off_on;
    if (!gameState.active) return
    if (event.code === 'KeyO') {
        if (controls.enabled) {
            controls.enabled = false;
            off_on = '–≤—ã–∫–ª';
        } else {
            controls.enabled = true;
            off_on = '–≤–∫–ª';
        }
        document.getElementById('OrbitConSet').innerHTML = off_on;
    } else if (event.code === 'KeyR' && CurrentActiveCam === 'observer') {
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 5, 0);
        controls.update();
    } else if (event.code === 'KeyT' && CurrentActiveCam === 'observer'){
        camera.position.set(1.20, 6, 21.74);
        camera.lookAt(0, 5, 0);
        controls.update();
    } else if (event.code === 'KeyB' && CurrentActiveCam === 'observer'){
        camera.position.set(-0.31, 14.50, -21.44);
        camera.lookAt(0, 5, 0);
        controls.update();
    } else if (event.code === 'KeyI' && CurrentActiveCam === 'observer'){
        camera.position.set(-21.20, 15, -0.82);
        camera.lookAt(0, 5, 0);
        controls.update();
    } else if (event.code === 'KeyY' && CurrentActiveCam === 'observer'){
        camera.position.set(0, -18.45, 0);
        camera.lookAt(0, 5, 0);
        controls.update();
    } else if (event.code === 'KeyS' && CurrentActiveCam === 'observer'){
        alert("–ù–∞—á–∞—Ç–æ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ –∫—É–±–∞");
        scrambleCube(20);
    } else if (event.code === 'KeyC' && CurrentActiveCam === 'observer'){
        solveCube();
    } else if (event.code === 'ArrowLeft' && CurrentActiveCam === 'observer'){
        rotateWholeCube(new THREE.Vector3(0, 1, 0), true)
    } else if (event.code === 'ArrowRight' && CurrentActiveCam === 'observer'){
        rotateWholeCube(new THREE.Vector3(0, 1, 0), false)
    } else if (event.code === 'ArrowUp'){
        rotateWholeCube(new THREE.Vector3(1, 0, 0), false)
    } else if (event.code === 'ArrowDown'){
        rotateWholeCube(new THREE.Vector3(1, 0, 0), true)
    }
});

function setupTriggerInteraction(triggerZones) {
    window.addEventListener('mousedown', (event) => {
        if (!gameState.active) return;
        if (event.button !== 0) return;
        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -((event.clientY / window.innerHeight) * 2 - 1);

        raycaster.setFromCamera(mouse, camera);
        const objects = getObjects();
        const intersects = raycaster.intersectObjects(objects, true);

        if (intersects.length > 0) {
            const intersect = intersects[0];
            startObject = intersect.object;
            selectedCube = startObject.parent; // –ü–æ–ª—É—á–∞–µ–º –≥—Ä—É–ø–ø—É –∫—É–±–∏–∫–∞
            showArrows(selectedCube);
            console.log('mousedown: object=', startObject.name, 'parent=', selectedCube.name);
        } else {
            hideArrows();
            console.log('mousedown: no cube hit');
        }
    });

    window.addEventListener('mousemove', (event) => {
        if (!gameState.active) return
        if (!isDragging && selectedCube) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -((event.clientY / window.innerHeight) * 2 - 1);
    
            raycaster.setFromCamera(mouse, camera);
            const arrowIntersects = raycaster.intersectObjects(arrows, true);
    
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ü–≤–µ—Ç –≤—Å–µ—Ö —Å—Ç—Ä–µ–ª–æ–∫ –¥–æ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ
            arrows.forEach(arrow => {
                const originalColor = arrow.material.userData.originalColor || arrow.material.color.getHex();
                arrow.material.color.set(originalColor);
            });
    
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É —Ç–æ–ª—å–∫–æ –¥–ª—è –ø–µ—Ä–µ—Å–µ—á—ë–Ω–Ω–æ–π —Å—Ç—Ä–µ–ª–∫–∏
            if (arrowIntersects.length > 0) {
                const arrow = arrowIntersects[0].object;
                arrow.material.color.set(0xff00ff); // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
            }
        }
    });
    

    window.addEventListener('mouseup', (event) => {
        if (!gameState.active) return
        if (!selectedCube) return;

        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -((event.clientY / window.innerHeight) * 2 - 1);

        raycaster.setFromCamera(mouse, camera);
        const arrowIntersects = raycaster.intersectObjects(arrows, true);

        if (arrowIntersects.length > 0) {
            const arrow = arrowIntersects[0].object;
            let axis = arrow.userData.direction.clone();
            const isCounterclockwise = arrow.userData.isRotate && !arrow.userData.rotationDirection
            //console.log(`Rotate TRUE/FALSE ${isCounterclockwise ? '–ü–†–û–¢–ò–í' : '–ü–û'}, axis=`, axis.toArray());           
            rotateLayer(selectedCube, axis, isCounterclockwise);
        }

        hideArrows();
        console.log('mouseup: arrows cleared');
    });
}

export function getCurrentCam() {
    return camera;
}

function startworld() {
    requestAnimationFrame(startworld);
    try {
        bodies.forEach(({ mesh, body }) => {
            mesh.position.copy(body.position);
            mesh.quaternion.copy(body.quaternion);
        });

        const pos = camera.position;
        const rot = camera.rotation;
        const rotDeg = {
            x: (rot.x * 180 / Math.PI).toFixed(2),
            y: (rot.y * 180 / Math.PI).toFixed(2),
            z: (rot.z * 180 / Math.PI).toFixed(2)
        };
        cameraInfoDiv.innerHTML = `
            Camera: ${CurrentActiveCam}<br>
            Position: [${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}]<br>
            Rotation: [${rotDeg.x}, ${rotDeg.y}, ${rotDeg.z}]¬∞
        `;

        renderer.render(scene, camera);
        stats.update();
    } catch (err) {
        console.error('–û—à–∏–±–∫–∞ –≤ –∏–≥—Ä–æ–≤–æ–º —Ü–∏–∫–ª–µ: ', err);
    }
}

window.addEventListener('load', () => {
    initThree();
    initCube(scene, world, () => {
        console.log('Cube loaded, Objects length=', getObjects().length);
        const triggerZones = createTriggerZones(6.12);
        triggerZones.forEach(zone => scene.add(zone));
        setupTriggerInteraction(triggerZones);
        initPlayer(scene, renderer, controls, controlsPointer);
        startworld();
    });   
});
---------
cube.js:
import * as THREE from 'https://unpkg.com/three@0.122.0/build/three.module.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/loaders/GLTFLoader.js';
import { camera, CurrentActiveCam, updateProgressBar } from './index.js';
import { gameState } from './menu.js';

let scene;
export let world;
const loaderGLTF = new GLTFLoader();
export const bodies = [];
let _objects = []; // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –º–∞—Å—Å–∏–≤
export const originalMaterials = new Map();
export const referencePositions = new Map(); // –ü–æ–∑–∏—Ü–∏–∏ —ç—Ç–∞–ª–æ–Ω–Ω—ã–π –ø–æ–∑–∏—Ü–∏–π –∏ –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω–æ–≤
// export const cubeState = new Map(); // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –º–∞—Ç—Ä–∏—Ü–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫—É–±–∏–∫–∞
export let historyrotation = [];
const raycaster = new THREE.Raycaster()

let referenceCube = null;

const validGroups = [
    'R1_GWR001', 'R2_WR002', 'R3_RWB003', 'R4_GR004', 'R5_CENTER_R005', 'R6_RB006', 'R7_GRY007', 'R8_RY008', 'R9_RBY009',
    'Mid1_GW001', 'Mid2_CENTER_W002', 'Mid3_WB003', 'Mid4_CENTER_G004', 'Mid5_CENTER_B005', 'Mid6_CENTER_B006', 'Mid7_YG007', 'Mid8_CENTER_Y008', 'Mid9_YB009',
    'O1_GOW001', 'O2_OW002', 'O3_OBW003', 'O4_GO004', 'O5_CENTER_O005', 'O6_OB006', 'O7_GYO007', 'O8_YO008', 'O9_OYB009'
];

// Getter –¥–ª—è Objects
export function getObjects() {
    return _objects;
}

let rotationGroup = null;
let cubesToRotate = [];
let arrowHelper = null;
let progressArrows = [];
let isRotating = false;
let rotationAxis = new THREE.Vector3();

export function initCube(sceneArg, worldArg, onLoadCallback) {
    scene = sceneArg;
    world = worldArg;

    initCannon();

    loaderGLTF.load("models/Cubuk-rubic_UltraLITE_withoutCamera.glb",
        (gltf) => {
            const model = gltf.scene;
            model.scale.set(1, 1, 1);
            model.position.set(0,5,0)
            scene.add(model);

            referenceCube = gltf.scene.clone();
            referenceCube.scale.set(1, 1, 1)
            referenceCube.position.set(0, 5, 0)
            referenceCube.visible = false;
            scene.add(referenceCube)

            model.updateMatrixWorld(true)
            referenceCube.updateMatrixWorld(true)

            console.log('***–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–æ–¥–µ–ª–∏***');
            model.traverse(child => {
                if (child.isGroup || child.isMesh) {
                    const worldPos = new THREE.Vector3();
                    child.getWorldPosition(worldPos);
                    const worldQuat = new THREE.Quaternion();
                    child.getWorldQuaternion(worldQuat);
                    if (child.isGroup){
                        console.log(`–ì—Ä.: ${child.name}, –¢–∏–ø: ${child.type}, –ü–æ–∑. [${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)}], –ö–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω: [${worldQuat.x.toFixed(2)}, ${worldQuat.y.toFixed(2)}, ${worldQuat.z.toFixed(2)}, ${worldQuat.w.toFixed(2)}]`);
                    }
                }
            });

            _objects.length = 0;
            model.traverse(child => {
                if (child.isGroup && validGroups.includes(child.name)) {
                    child.traverse(mesh => {
                        if (mesh.isMesh) {
                            const clonedMaterial = mesh.material.clone();
                            if (mesh.material.emissive) {
                                clonedMaterial.emissive = mesh.material.emissive.clone();
                                clonedMaterial.emissiveIntensity = mesh.material.emissiveIntensity;
                            }
                            if (mesh.material.map) clonedMaterial.map = mesh.material.map;
                            originalMaterials.set(mesh.uuid, clonedMaterial);
                            mesh.castShadow = true;
                            mesh.receiveShadow = true;
                            mesh.material.emissiveIntensity = 0;
                            mesh.geometry.computeVertexNormals();
                            if (!mesh.geometry.boundingBox) mesh.geometry.computeBoundingBox();
                            mesh.raycast = THREE.Mesh.prototype.raycast;
                        }
                    });
                    _objects.push(child);
                    const worldPos = new THREE.Vector3();
                    const worldQuat = new THREE.Quaternion();
                    child.getWorldPosition(worldPos);
                    child.getWorldQuaternion(worldQuat);
                    referencePositions.set(child.name, {
                        position: worldPos.clone(),
                        quaternion: worldQuat.clone()
                    });

                    console.log(` –ü–æ–ª–Ω–æ–µ –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏–µ –û–±—ä–µ–∫—Ç–∞: ${child.name}, –¢–∏–ø: ${child.type}, –ü–æ–∑–∏—Ü–∏—è: [${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)}]`);
                    child.children.forEach(color => {
                        const colormat = color.material
                        console.log(`–ù–∞–∑–≤–∞–Ω–∏–µ —Ü–≤–µ—Ç–∞: ${colormat.name}, —Ü–≤–µ—Ç: ${colormat.color.toArray()}, —Ç–∏–ø: ${colormat.type} \n -------------------`)                                                
                    })
                }
            });

            console.log('***–≠—Ç–∞–ª–æ–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏***');
            referencePositions.forEach((data, name) => {
                console.log(`–≠–ü –ì—Ä.: ${name} –ü–æ–∑–∏—Ü–∏—è: [${data.position.x.toFixed(2)}, ${data.position.y.toFixed(2)}, ${data.position.z.toFixed(2)}] –ö–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω: [${data.quaternion.x.toFixed(2)}, ${data.quaternion.y.toFixed(2)}, ${data.quaternion.z.toFixed(2)}, ${data.quaternion.w.toFixed(2)}]`);
            });
            console.log('initCube: Objects filled, length=', _objects.length);
            _objects.forEach((obj, i) => {
                console.log(`Object ${i}: ${obj.name}, Children: ${obj.children.length}`);
            });

            const body = new CANNON.Body({
                mass: 1,
                position: new CANNON.Vec3(0, 5, 0),
                shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5))
            });
            world.addBody(body);
            bodies.push({ mesh: model, body });
            console.log(`bodies initialized, lenght: ${bodies.length}`)

            if (onLoadCallback) onLoadCallback();
        },
        undefined,
        (error) => {
            console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏:", error);
        }
    );
}

export function initCannon() {
    world = new CANNON.World();
    world.broadphase = new CANNON.NaiveBroadphase();
    world.solver.iterations = 10;
    const groundBody = new CANNON.Body({
        mass: 0,
        position: new CANNON.Vec3(0, 0, 0),
        shape: new CANNON.Plane(),
    });
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    world.addBody(groundBody);
}

export function getCubesInLayer(normal, clickedObject) {
    const layerCubes = [];
    const threshold = 0.9;
    const clickedPos = new THREE.Vector3();

    clickedObject.getWorldPosition(clickedPos);
    const axis = Math.abs(normal.x) > threshold ? 'x' :
                 Math.abs(normal.y) > threshold ? 'y' : 'z';
    let layerCoord = Math.round(clickedPos[axis]);

    _objects.forEach(cube => {
        const cubePos = new THREE.Vector3();
        cube.getWorldPosition(cubePos);
        if (Math.abs(cubePos[axis] - layerCoord) < 0.1) {
            layerCubes.push(cube);
        }
    });

//    console.log(`–°–ª–æ–π –ø–æ –æ—Å–∏: ${axis}, –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞: ${layerCoord}, –∫—É–±–∏–∫–æ–≤: ${layerCubes.length}`);
    return { cubes: layerCubes };
}

export function checkFpsHit(mousePos) {
    if (CurrentActiveCam !== 'player') return null;
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –º—ã—à–∏ –≤–º–µ—Å—Ç–æ —Ü–µ–Ω—Ç—Ä–∞ —ç–∫—Ä–∞–Ω–∞
    raycaster.setFromCamera(mousePos || new THREE.Vector2(0, 0), camera);
    const intersects = raycaster.intersectObjects(_objects, true);
    return intersects[0] || null;
}

export function rotateLayer(object, normal, isCounterclockwise = false) {
    return new Promise((resolve) => {
        if (isRotating || !object.parent || !normal.lengthSq()) {
            console.log('rotateLayer: blocked', { isRotating, hasParent: !!object.parent, normalLength: normal.lengthSq() });
            resolve();
            return;
        }
        // console.log('–í—Ä–∞—â–µ–Ω–∏–µüîÉ: ', {
        //     object: object.name,
        //     normal: { x: normal.x, y: normal.y, z: normal.z },
        //     camMode: CurrentActiveCam,
        //     direction: isCounterclockwise ? '–ø—Ä–æ—Ç–∏–≤ —á–∞—Å–æ–≤–æ–π' : '–ø–æ —á–∞—Å–æ–≤–æ–π'
        // });

        const layerData = getCubesInLayer(normal, object);
        cubesToRotate = layerData.cubes;

  //      console.log('rotateLayer: cubes to rotate=', cubesToRotate.length);
        if (cubesToRotate.length === 0) {
            console.log('rotateLayer: no cubes to rotate');
            resolve();
            return;
        }

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –≤—Ä–∞—â–µ–Ω–∏—è
        historyrotation.push({
            type: 'layer',
            objectName: object.name,
            normal: normal.clone(),
            isCounterclockWise: isCounterclockwise
        })

        if (arrowHelper) {
            scene.remove(arrowHelper);
            arrowHelper = null;
        }
        progressArrows.forEach(arrow => scene.remove(arrow));
        progressArrows = [];

        rotationGroup = new THREE.Group();
        const centerPoint = new THREE.Vector3();
        cubesToRotate.forEach(cube => {
            const pos = new THREE.Vector3();
            cube.getWorldPosition(pos);
            centerPoint.add(pos);
        });
        centerPoint.divideScalar(cubesToRotate.length);

        rotationGroup.position.copy(centerPoint);
        scene.add(rotationGroup);

        cubesToRotate.forEach(cube => {
            const pos = new THREE.Vector3();
            cube.getWorldPosition(pos);
            cube.position.copy(pos.sub(centerPoint));
            scene.remove(cube);
            rotationGroup.add(cube);
        });

        rotationAxis.copy(normal).normalize();
        isRotating = true;

        updateProgressArrows(0);
        arrowHelper = new THREE.ArrowHelper(rotationAxis, rotationGroup.position, 2, 0xff0000);
        scene.add(arrowHelper);

        const targetAngle = isCounterclockwise ? -Math.PI / 2 : Math.PI / 2;
        const duration = 300;
        const startTime = performance.now();

        function animateRotation(currentTime) {
            if (!rotationGroup) {
                resolve();
                return;
            }
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const angle = targetAngle * progress;

            rotationGroup.rotation.set(0, 0, 0);
            rotationGroup.rotateOnAxis(rotationAxis, angle);

            if (progress < 1) {
                requestAnimationFrame(animateRotation);
            } else {
                finishRotation();
                resolve();
            }
        }

        requestAnimationFrame(animateRotation);
    });
}

export function rotateWholeCube(axis, isCounterclockwise = false) {
    return new Promise((resolve) => {
        if (isRotating) {
            console.log('rotateWholeCube: blocked, rotation in progress');
            resolve();
            return;
        }

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –≤—Ä–∞—â–µ–Ω–∏—è
        historyrotation.push({
            type: 'whole',
            axis: axis.clone(),
            isCounterclockWise: isCounterclockwise
        })

        // –°–æ–∑–¥–∞—ë–º –≥—Ä—É–ø–ø—É –¥–ª—è –≤—Ä–∞—â–µ–Ω–∏—è
        rotationGroup = new THREE.Group();
        const centerPoint = new THREE.Vector3(0, 5, 0); // –¶–µ–Ω—Ç—Ä –∫—É–±–∏–∫–∞
        rotationGroup.position.copy(centerPoint);
        scene.add(rotationGroup);

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –∏ –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω—ã –≤—Å–µ—Ö –∫—É–±–∏–∫–æ–≤
        const initialStates = new Map();
        _objects.forEach(cube => {
            const pos = new THREE.Vector3();
            cube.getWorldPosition(pos);
            const quat = cube.getWorldQuaternion(new THREE.Quaternion());
            initialStates.set(cube, { position: pos.clone(), quaternion: quat.clone() });
            // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –∫—É–±–∏–∫ –≤ rotationGroup
            cube.position.copy(pos.sub(centerPoint));
            scene.remove(cube);
            rotationGroup.add(cube);
        });

        rotationAxis.copy(axis).normalize();
        isRotating = true;

        // –û—á–∏—â–∞–µ–º –∏ —Å–æ–∑–¥–∞—ë–º —Å—Ç—Ä–µ–ª–∫–∏
        if (arrowHelper) {
            scene.remove(arrowHelper);
            arrowHelper = null;
        }
        progressArrows.forEach(arrow => scene.remove(arrow));
        progressArrows = [];
        updateProgressArrows(0);
        arrowHelper = new THREE.ArrowHelper(rotationAxis, rotationGroup.position, 2, 0xff0000);
        scene.add(arrowHelper);

        const targetAngle = isCounterclockwise ? -Math.PI / 2 : Math.PI / 2;
        const duration = 300;
        const startTime = performance.now();

        function animateRotation(currentTime) {
            if (!rotationGroup) {
                resolve();
                return;
            }
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const angle = targetAngle * progress;

            rotationGroup.rotation.set(0, 0, 0);
            rotationGroup.rotateOnAxis(rotationAxis, angle);

            updateProgressArrows(angle);

            if (progress < 1) {
                requestAnimationFrame(animateRotation);
            } else {
                finishWholeRotation(initialStates);
                resolve();
            }
        }

        requestAnimationFrame(animateRotation);
    });
}

function finishWholeRotation(initialStates) {
    if (!rotationGroup) return;

    // –ü–µ—Ä–µ–Ω–æ—Å–∏–º –∫—É–±–∏–∫–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤ —Å—Ü–µ–Ω—É
    const tempContainer = new THREE.Group();
    scene.add(tempContainer);
    tempContainer.position.copy(rotationGroup.position);
    tempContainer.quaternion.copy(rotationGroup.quaternion);

    while (rotationGroup.children.length > 0) {
        const cube = rotationGroup.children[0];
        const originalPos = new THREE.Vector3().copy(cube.position);
        rotationGroup.remove(cube);
        tempContainer.add(cube);
        cube.position.copy(originalPos);
    }

    while (tempContainer.children.length > 0) {
        const cube = tempContainer.children[0];
        const worldPos = new THREE.Vector3();
        cube.getWorldPosition(worldPos);
        const worldQuat = cube.getWorldQuaternion(new THREE.Quaternion());

        // –û–∫—Ä—É–≥–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏ –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω—ã
        worldPos.x = Math.round(worldPos.x * 1000) / 1000;
        worldPos.y = Math.round(worldPos.y * 1000) / 1000;
        worldPos.z = Math.round(worldPos.z * 1000) / 1000;
        worldQuat.x = Math.round(worldQuat.x * 1000) / 1000;
        worldQuat.y = Math.round(worldQuat.y * 1000) / 1000;
        worldQuat.z = Math.round(worldQuat.z * 1000) / 1000;
        worldQuat.w = Math.round(worldQuat.w * 1000) / 1000;

        tempContainer.remove(cube);
        scene.attach(cube);
        cube.position.copy(worldPos);
        cube.quaternion.copy(worldQuat);

        // –û–±–Ω–æ–≤–ª—è–µ–º referencePositions –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π —Ä–∞–±–æ—Ç—ã –¥—Ä—É–≥–∏—Ö —Ñ—É–Ω–∫—Ü–∏–π
        referencePositions.set(cube.name, {
            position: worldPos.clone(),
            quaternion: worldQuat.clone()
        });
    }

    scene.remove(tempContainer);
    if (arrowHelper) {
        scene.remove(arrowHelper);
        arrowHelper = null;
    }
    progressArrows.forEach(arrow => scene.remove(arrow));
    progressArrows = [];
    scene.remove(rotationGroup);
    isRotating = false;
    rotationGroup = null;
    cubesToRotate = []; // –û—á–∏—â–∞–µ–º, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞—Ç—å rotateLayer

    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —Ñ–∏–∑–∏–∫—É
    if (bodies.length > 0 && bodies[0] && bodies[0].body && bodies[0].mesh) {
        const centerPos = new THREE.Vector3(0, 5, 0);
        bodies[0].body.position.copy(new CANNON.Vec3(centerPos.x, centerPos.y, centerPos.z));
        bodies[0].mesh.position.copy(centerPos);
        // –ö–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω —Ñ–∏–∑–∏—á–µ—Å–∫–æ–≥–æ —Ç–µ–ª–∞ –Ω–µ –æ–±–Ω–æ–≤–ª—è–µ–º, —Ç–∞–∫ –∫–∞–∫ –≤—Ä–∞—â–µ–Ω–∏–µ –∑–∞—Ç—Ä–∞–≥–∏–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤–∏–∑—É–∞–ª—å–Ω—ã–µ –∫—É–±–∏–∫–∏
    }
}

function updateProgressArrows(currentAngle) {
    progressArrows.forEach(arrow => scene.remove(arrow));
    progressArrows = [];

    const progress = Math.min(Math.abs(currentAngle) / (Math.PI / 2), 1);
    const startColor = new THREE.Color(0xff0000);
    const endColor = new THREE.Color(0x00ff00);
    const arrowColor = startColor.clone().lerp(endColor, progress);

    const arrowLength = 2 + progress * 1;
    const arrow1 = new THREE.ArrowHelper(rotationAxis, rotationGroup.position, arrowLength, arrowColor.getHex(), 0.3, 0.1);
    scene.add(arrow1);
    progressArrows.push(arrow1);

    const arrow2 = new THREE.ArrowHelper(rotationAxis.clone().negate(), rotationGroup.position, arrowLength, arrowColor.getHex(), 0.3, 0.1);
    scene.add(arrow2);
    progressArrows.push(arrow2);
}

function finishRotation() {
    if (!rotationGroup) return;

    cubesToRotate.forEach(cube => {
        cube.traverse(child => {
            if (child.isMesh && originalMaterials.has(child.uuid)) {
                child.material = originalMaterials.get(child.uuid).clone();
                child.material.needsUpdate = true;
                child.geometry.computeVertexNormals();
                if (child.material.emissive) {
                    child.material.emissiveIntensity = 0;
                }
            }
        });
    });

    const tempContainer = new THREE.Group();
    scene.add(tempContainer);
    tempContainer.position.copy(rotationGroup.position);
    tempContainer.quaternion.copy(rotationGroup.quaternion);

    while (rotationGroup.children.length > 0) {
        const cube = rotationGroup.children[0];
        const originalPos = new THREE.Vector3().copy(cube.position);
        rotationGroup.remove(cube);
        tempContainer.add(cube);
        cube.position.copy(originalPos);
    }

    while (tempContainer.children.length > 0) {
        const cube = tempContainer.children[0];
        const worldPos = new THREE.Vector3();
        cube.getWorldPosition(worldPos);
        const worldQuater = cube.getWorldQuaternion(new THREE.Quaternion());

        worldPos.x = Math.round(worldPos.x * 1000) / 1000;
        worldPos.y = Math.round(worldPos.y * 1000) / 1000;
        worldPos.z = Math.round(worldPos.z * 1000) / 1000;
        worldQuater.x = Math.round(worldQuater.x * 1000) / 1000;
        worldQuater.y = Math.round(worldQuater.y * 1000) / 1000;
        worldQuater.z = Math.round(worldQuater.z * 1000) / 1000;
        worldQuater.w = Math.round(worldQuater.w * 1000) / 1000;

        tempContainer.remove(cube);
        scene.attach(cube);
        cube.position.copy(worldPos);
        cube.quaternion.copy(worldQuater);
    }

    scene.remove(tempContainer);
    if (arrowHelper) {
        scene.remove(arrowHelper);
        arrowHelper = null;
    }
    progressArrows.forEach(arrow => scene.remove(arrow));
    progressArrows = [];
    scene.remove(rotationGroup);
    isRotating = false;
    cubesToRotate = [];
    rotationGroup = null;

    // —Ñ–∏–∑–∏–∫–∞
    if (bodies.length > 0 && bodies[0] && bodies[0].body && bodies[0].mesh){
        bodies[0].body.position.copy(new CANNON.Vec3(0, 5, 0));
        bodies[0].mesh.position.copy(new THREE.Vector3(0, 5, 0));
    }
}

export async function scrambleCube(numMoves = 20){
    if (isRotating){
        console.warn(`–ü–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–æ, —Ç.–∫ —Å–µ–π—á–∞—Å –∫—É–±–∏–∫ –≤—Ä–∞—â–∞–µ—Ç—Å—è`);
        return;
    }
    updateProgressBar(0)

    const axes = [
        new THREE.Vector3(1, 0, 0),
        new THREE.Vector3(0, 1, 0),
        new THREE.Vector3(0, 0, 1)
    ];

    for (let i = 0; i < numMoves; i++){
        const cube = _objects[Math.floor(Math.random() * _objects.length)];
        const axis = axes[Math.floor(Math.random() * axes.length)];
        const isCounterclockwise = Math.random() > 0.5;

        console.log(`–ü–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ: –¥–≤–∏–∂–µ–Ω–∏–µ ${i+1}/${numMoves}: cube=${cube.name}, axis=${axis.toArray()}, direction=${isCounterclockwise ? '–ø—Ä–æ—Ç–∏–≤ —á–∞—Å–æ–≤–æ–π' : '–ø–æ —á–∞—Å–æ–≤–æ–π'}`)
        await rotateLayer(cube, axis, isCounterclockwise);
    }
    console.log(`–ü–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ –∫—É–±–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–æ-—É—Å–ø–µ—à–Ω–æ`)
}

export async function solveCube() {
    if (isRotating) { alert("–°–±–æ—Ä–∫–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∞, —Ç.–∫ —Å–µ–π—á–∞—Å –∫—É–±–∏–∫ –≤—Ä–∞—â–∞–µ—Ç—Å—è"); updateProgressBar(0); return; }
    if (gameState.mode === 'normal') { alert("–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ –≤ –æ–±—ã—á–Ω–æ–º —Ä–µ–∂–∏–º–µ"); updateProgressBar(0); return;} 

    optimizeHistory()
    alert("–ù–∞—á–∞—Ç–∞ —Å–±–æ—Ä–∫–∞")
    
    // –ø—Ä–æ—Ö–æ–¥–∏–º –ø–æ –∏—Å—Ç–æ—Ä–∏–∏ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏
    for (let i = historyrotation.length - 1; i>=0; i--){
        const move = historyrotation[i];
        if (move.type === 'layer'){
            // –Ω–∞—Ö–æ–¥–∏–º –æ–±—ä–µ–∫—Ç –ø–æ –∏–º–µ–Ω–∏
            const object = _objects.find(obj => obj.name === move.objectName)
            if (!object){
                alert(`–û–±—ä–µ–∫—Ç: ${move.object} –¥–ª—è –≤—Ä–∞—â–µ–Ω–∏—è, –Ω–µ –Ω–∞–π–¥–µ–Ω`)
            }
            await rotateLayer(object, move.normal, !move.isCounterclockWise); 
        } else if (move.type === 'whole'){
            await rotateWholeCube(move.axis, !move.isCounterclockWise)
        }
    }
    if (isCubeSolved()){
        console.log("–ö—É–±–∏–∫ —Å–æ–±—Ä–∞–Ω, –æ—á–∏—â–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é –≤—Ä–∞—â–µ–Ω–∏–π");
        updateProgressBar(100);
        historyrotation = [];
    } else {
        console.warn("–ö—É–±–∏–∫ –Ω–µ —Å–æ–±—Ä–∞–Ω –ø–æ—Å–ª–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏");
    }
    console.log("–°–±–æ—Ä–∫–∞ –∫—É–±–∏–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞");
}

function optimizeHistory() {
    const optimized = [];
    for (let i = 0; i < historyrotation.length; i++) {
        const current = historyrotation[i];
        if (optimized.length > 0) {
            const last = optimized[optimized.length - 1];
            if (
                current.type === last.type &&
                current.objectName === last.objectName &&
                current.normal.equals(last.normal) &&
                current.isCounterclockwise === !last.isCounterclockwise
            ) {
                optimized.pop(); // –£–¥–∞–ª—è–µ–º –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã–µ –≤—Ä–∞—â–µ–Ω–∏—è
                continue;
            }
        }
        optimized.push(current);
    }
    historyrotation = optimized;
    console.log(`–ò—Å—Ç–æ—Ä–∏—è –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–∞, –¥–ª–∏–Ω–∞: ${historyrotation.length}`);
}

export function checkCubeSolved(){
    return isCubeSolved()
}

function isCubeSolved(){
    const tolerance = 0.01; // –î–æ–ø—É—Å—Ç–∏–º–∞—è –ø–æ–≥—Ä–µ—à–Ω–æ—Å—Ç—å –¥–ª—è –ø–æ–∑–∏—Ü–∏–π –∏ –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω–æ–≤
    let isSolved = true

    _objects.forEach(cube => {
        const refData = referencePositions.get(cube.name)
        if (!refData){
            console.warn(`–≠—Ç–∞–ª–æ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã: ${cube.name}`);
            isSolved = false;
            return;
        }
        const currentPos = new THREE.Vector3();
        cube.getWorldPosition(currentPos);
        const currentQuat = cube.getWorldQuaternion(new THREE.Quaternion());

        // –û–∫—Ä—É–≥–ª—è–µ–º –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
        currentPos.x = Math.round(currentPos.x * 1000) / 1000;
        currentPos.y = Math.round(currentPos.y * 1000) / 1000;
        currentPos.z = Math.round(currentPos.z * 1000) / 1000;
        currentQuat.x = Math.round(currentQuat.x * 1000) / 1000;
        currentQuat.y = Math.round(currentQuat.y * 1000) / 1000;
        currentQuat.z = Math.round(currentQuat.z * 1000) / 1000;
        currentQuat.w = Math.round(currentQuat.w * 1000) / 1000;

        const refPos = refData.position;
        const refQuat = refData.quaternion;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–∑–∏—Ü–∏–∏
        if (
            Math.abs(currentPos.x - refPos.x) > tolerance ||
            Math.abs(currentPos.y - refPos.y) > tolerance ||
            Math.abs(currentPos.z - refPos.z) > tolerance
        ) {
            console.log(`–ö—É–±–∏–∫ ${cube.name}: –ø–æ–∑–∏—Ü–∏—è –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç. –¢–µ–∫—É—â–∞—è: ${currentPos.toArray()}, –≠—Ç–∞–ª–æ–Ω: ${refPos.toArray()}`);
            isSolved = false;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é
        if (
            Math.abs(currentQuat.x - refQuat.x) > tolerance ||
            Math.abs(currentQuat.y - refQuat.y) > tolerance ||
            Math.abs(currentQuat.z - refQuat.z) > tolerance ||
            Math.abs(currentQuat.w - refQuat.w) > tolerance
        ) {
            console.log(`–ö—É–±–∏–∫ ${cube.name}: –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç. –¢–µ–∫—É—â–∞—è: ${[currentQuat.x, currentQuat.y, currentQuat.z, currentQuat.w]}, –≠—Ç–∞–ª–æ–Ω: ${[refQuat.x, refQuat.y, refQuat.z, refQuat.w]}`);
            isSolved = false;
        }
    });

    return isSolved;
}
--------
menu.js:
import { scrambleCube } from "./cube.js";

// –≠–ª–µ–º–µ–Ω—Ç—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
const mainMenu = document.getElementById('mainMenu');
export const congratsModal = document.getElementById('congratsModal');
const helpModal = document.getElementById('helpModal');
const creatorModal = document.getElementById('creatorModal');

export let gameState = {
    active: false,
    mode: null,
    startTime: 0,
    solved: false // –§–ª–∞–≥, —á—Ç–æ –∫—É–±–∏–∫ —Å–æ–±—Ä–∞–Ω

}
export let timerInterval;

// –§—É–Ω–∫—Ü–∏–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–æ–¥–∞–ª–∫–∞–º–∏
function showModal(modal){
    if (modal){
        // –°–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ –º–æ–¥–∞–ª–∫–∏ –ø–µ—Ä–µ–¥ –ø–æ–∫–∞–∑–æ–º –Ω–æ–≤–æ–π
        document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
        modal.style.display = 'block';
    }
}

function hideModals() {
    document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
}

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é
document.getElementById('normalMode').addEventListener('click', () => {
    gameState.active = true
    gameState.mode = 'normal';
    gameState.solved = false
    mainMenu.style.display = 'none';
    startGameTimer();
    scrambleCube();
});

document.getElementById('freeMode').addEventListener('click', () => {
    gameState.active = true
    gameState.mode = 'free';
    mainMenu.style.display = 'none';
    startGameTimer();
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ "–ü–æ–º–æ—â—å" –∏ "–°–æ–∑–¥–∞—Ç–µ–ª—å"
document.getElementById('helpBtn').addEventListener('click', () => showModal(helpModal));
document.getElementById('creatorBtn').addEventListener('click', () => showModal(creatorModal));

// –û–±—â–∏–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–∫—Ä—ã—Ç–∏—è –¥–ª—è –≤—Å–µ—Ö –º–æ–¥–∞–ª–æ–∫
document.querySelectorAll('.close-btn').forEach(btn => {
    btn.addEventListener('click', hideModals);
});

// –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ –∫–ª–∏–∫—É –≤–Ω–µ –æ–∫–Ω–∞
window.addEventListener('click', (event) => {
    if (event.target.classList.contains('modal')) {
        hideModals();
    }
});

// –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ ESC
document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') {
        hideModals();
    }
});

// –¢–∞–π–º–µ—Ä –∏–≥—Ä—ã
function startGameTimer() {
    gameState.startTime = Date.now();
    timerInterval = setInterval(() => {
        document.getElementById('solveTime').textContent = 
            ((Date.now() - gameState.startTime)/1000).toFixed(1);
    }, 100);
}

export function stopTimer() {
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
}
-------
checkProtocol.js
document.addEventListener('DOMContentLoaded', () => {
    if (window.location.protocol === 'file:') {
        document.body.classList.add('page-error');
        document.body.style.backgroundImage = "url('textures/pixel.jpg')";
        const menu = document.getElementById('menu_info');
        const setting = document.getElementById('menu_settings');
        const orbitCon = document.getElementById('OrbitCon');
        if (menu) menu.style.display = 'none';
        if (setting) setting.style.display = 'none';
        if (orbitCon) orbitCon.style.display = 'none';
        const errorMes = document.createElement('div');
        errorMes.id = 'eMessage';
        errorMes.textContent = '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø—É—Å—Ç–∏—Ç–µ –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä (–Ω–∞–ø—Ä–∏–º–µ—Ä, FiveServer), —á—Ç–æ–±—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Ä–∞–±–æ—Ç–∞–ª–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ. –≠—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ CORS –∏ –∑–∞–≥—Ä—É–∑–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤.';
        document.body.appendChild(errorMes);
        throw new Error('–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —á–µ—Ä–µ–∑ file:// –∏–∑-–∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π CORS.');
    } else {
        const MenuScript = document.createElement('script')
        MenuScript.src = 'Scripts/menu.js';
        MenuScript.type = 'module';
        document.body.appendChild(MenuScript);
    }
});
----------